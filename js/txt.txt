// ---- auth.js  ----

// --- Lógica de Autenticación (Simulada) ---

// Referencias a elementos (se asignarán en main.js o se buscarán aquí)
let loginForm, registerForm, toggleAuthLink, authTitle, logoutButton;

function handleLogin(e) {
    e.preventDefault();
    const emailInput = document.getElementById('login-email');
    const passwordInput = document.getElementById('login-password');
    if (!emailInput || !passwordInput) return; // Guard clause

    const email = emailInput.value;
    const password = passwordInput.value;
    console.log("Host Login attempt:", email);

    // --- SIMULACIÓN ---
    if (email === "admin" && password === "1234") {
         console.log("Hardcoded login successful for admin");
         window.hostAuthToken = "fake-admin-token-" + Date.now();
         window.hostEmail = email;
         localStorage.setItem('hostAuthToken', window.hostAuthToken);
         localStorage.setItem('hostEmail', window.hostEmail);
         loadQuizzesFromStorage(); // Asume que esta función está disponible (desde dashboard.js)
         showView('dashboard-view');
         displayError('login-error', '');
         if(loginForm) loginForm.reset();
    } else {
         displayError('login-error', 'Credenciales incorrectas (Prueba admin / 1234 para demo).');
    }
}

function handleRegister(e) {
     e.preventDefault();
     const emailInput = document.getElementById('register-email');
     const passwordInput = document.getElementById('register-password'); // Necesario para posible validación futura
     const loginEmailInput = document.getElementById('login-email');
     if (!emailInput || !passwordInput || !loginEmailInput || !registerForm) return;

     // --- SIMULACIÓN ---
     const email = emailInput.value;
     alert(`Simulación: Registro exitoso para ${email} (no guardado). Usa admin / 1234 para entrar.`);
     registerForm.reset();
     toggleAuthForms();
     loginEmailInput.value = email; // Pre-fill login form
     displayError('register-error', '');
}

function toggleAuthForms() {
    // Re-get elements in case they weren't ready initially
    loginForm = loginForm || document.getElementById('login-form');
    registerForm = registerForm || document.getElementById('register-form');
    authTitle = authTitle || document.getElementById('auth-title');
    toggleAuthLink = toggleAuthLink || document.getElementById('toggle-auth-link');

    if (!loginForm || !registerForm || !authTitle || !toggleAuthLink) return;

    const isLoginVisible = loginForm.style.display !== 'none';
    loginForm.style.display = isLoginVisible ? 'none' : 'block';
    registerForm.style.display = isLoginVisible ? 'block' : 'none';
    authTitle.textContent = isLoginVisible ? 'Registrarse' : 'Iniciar Sesión';
    toggleAuthLink.textContent = isLoginVisible ? '¿Ya tienes cuenta? Inicia Sesión' : '¿No tienes cuenta? Regístrate';
     displayError('login-error', '');
     displayError('register-error', '');
}

 function handleLogout() {
    if (window.hostWebSocket && window.hostWebSocket.readyState === WebSocket.OPEN) {
        window.hostWebSocket.close(1000, "Host logged out");
    }
    window.hostAuthToken = null;
    window.hostEmail = null;
    localStorage.removeItem('hostAuthToken');
    localStorage.removeItem('hostEmail');
    // No borramos los quizzes del localStorage al hacer logout
    resetHostState(); // Utility function
    showView('auth-view'); // Utility function

    // Reset forms if they exist
    loginForm = loginForm || document.getElementById('login-form');
    registerForm = registerForm || document.getElementById('register-form');
    if(loginForm) loginForm.reset();
    if(registerForm) registerForm.reset();

    console.log("Host logged out");
 }

 function initAuth() {
    // Get elements needed by this module
    loginForm = document.getElementById('login-form');
    registerForm = document.getElementById('register-form');
    toggleAuthLink = document.getElementById('toggle-auth-link');
    authTitle = document.getElementById('auth-title');
    logoutButton = document.getElementById('logout-button');

    // Add listeners if elements exist
    if(loginForm) loginForm.addEventListener('submit', handleLogin);
    if(registerForm) registerForm.addEventListener('submit', handleRegister);
    if(toggleAuthLink) toggleAuthLink.addEventListener('click', (e) => { e.preventDefault(); toggleAuthForms(); });
    if(logoutButton) logoutButton.addEventListener('click', handleLogout);
 }

// ---- builder.js  ----

// --- Lógica del Quiz Builder (con GIFT y Drag & Drop) ---

// Referencias a elementos
let quizBuilderView, builderTitle, quizBuilderForm, quizIdInput, quizTitleInput,
    questionsContainer, addQuestionBtn, cancelQuizBuilderBtnBottom, // quitado cancelQuizBuilderBtnTop como variable global
    saveQuizBtn, // ID del botón de guardar ORIGINAL (inferior)
    questionTemplate, optionTemplate,
    importGiftBtn, giftFileInput, giftFileNameSpan, giftImportStatus;

let nextQuestionTempId = 0; // Para IDs temporales únicos de preguntas/opciones
let draggedQuestion = null; // Para drag & drop
let dropZone = null; // Para el placeholder visual de drag & drop
let infoModalInstance = null; // Instancia para el modal de información genérico

/**
 * Muestra un modal de Bootstrap genérico con un mensaje.
 * @param {string} message El mensaje a mostrar en el cuerpo del modal.
 * @param {string} [title='Aviso'] El título opcional para el modal.
 */
function showInfoModal(message, title = 'Aviso') {
    const modalElement = document.getElementById('infoModal');
    const modalTitleElement = document.getElementById('infoModalLabel');
    const modalBodyElement = document.getElementById('infoModalBody');

    if (!modalElement || !modalTitleElement || !modalBodyElement) {
        console.error("Elementos del modal de información no encontrados (#infoModal, #infoModalLabel, #infoModalBody)");
        // Fallback a alert si el modal no está listo
        alert(message);
        return;
    }

    // Establecer título y mensaje
    modalTitleElement.textContent = title;
    modalBodyElement.textContent = message; // Usar textContent para seguridad

    // Obtener o crear la instancia del modal y mostrarlo
    if (!infoModalInstance) {
        // Asegurarse de que Bootstrap esté cargado
        if (typeof bootstrap !== 'undefined' && bootstrap.Modal) {
            infoModalInstance = new bootstrap.Modal(modalElement);
        } else {
            console.error("Bootstrap Modal no está disponible. Asegúrate de que el JS de Bootstrap esté cargado.");
            alert(message); // Fallback si Bootstrap no funciona
            return;
        }
    }
    // Prevenir error si la instancia no se pudo crear
    if (infoModalInstance) {
        infoModalInstance.show();
    }
}


function openQuizBuilder(quiz = null) {
    // Get elements needed by the builder
    quizBuilderView = quizBuilderView || document.getElementById('quiz-builder-view');
    builderTitle = builderTitle || document.getElementById('builder-title');
    quizBuilderForm = quizBuilderForm || document.getElementById('quiz-builder-form');
    quizIdInput = quizIdInput || document.getElementById('quiz-id');
    quizTitleInput = quizTitleInput || document.getElementById('quiz-title');
    questionsContainer = questionsContainer || document.getElementById('questions-container');
    giftFileInput = giftFileInput || document.getElementById('gift-file-input');
    giftFileNameSpan = giftFileNameSpan || document.getElementById('gift-file-name');
    giftImportStatus = giftImportStatus || document.getElementById('gift-import-status');

    if (!quizBuilderView || !builderTitle || !quizBuilderForm || !quizIdInput || !quizTitleInput || !questionsContainer || !giftFileInput || !giftFileNameSpan || !giftImportStatus) {
        console.error("Quiz builder elements not found!");
        return;
    }


    nextQuestionTempId = 0; // Reiniciar contador para IDs/nombres de radio
    questionsContainer.innerHTML = '';
    quizBuilderForm.reset();
    giftFileInput.value = '';
    giftFileNameSpan.textContent = '';
    giftFileNameSpan.style.display = 'none';
    giftImportStatus.textContent = '';
    window.currentQuizForBuilder = null; // Limpiar quiz anterior

    if (quiz) {
         // Clonar PROFUNDAMENTE para evitar modificar el original en la lista 'quizzes'
         window.currentQuizForBuilder = JSON.parse(JSON.stringify(quiz));
         builderTitle.textContent = "Editar Cuestionario";
         quizIdInput.value = window.currentQuizForBuilder.id;
         quizTitleInput.value = window.currentQuizForBuilder.title;
         console.log("Loading quiz for editing:", window.currentQuizForBuilder.id);
         if (window.currentQuizForBuilder.questions && window.currentQuizForBuilder.questions.length > 0) {
             window.currentQuizForBuilder.questions.forEach(q => addQuestionBlock(q));
         } else {
              addQuestionBlock(); // Añadir una vacía si no tiene
         }
    } else {
        builderTitle.textContent = "Crear Nuevo Cuestionario";
        quizIdInput.value = ''; // Sin ID para nuevo quiz
        addQuestionBlock(); // Añadir una pregunta inicial
    }
     enableDragAndDrop(); // Habilitar Drag & Drop
     updateBuilderUIState(); // Actualizar estado inicial
    showView('quiz-builder-view'); // Utility function (debe estar definida globalmente o importada)
}

function loadQuizForEditing(quizId) {
     // Asegurarse que quizzes esté cargado
     if (!window.quizzes || !Array.isArray(window.quizzes) || window.quizzes.length === 0) { // Comprobación más robusta
         console.warn("Quizzes not loaded yet, cannot edit.");
         // Idealmente, intentar cargar y luego reintentar, o mostrar mensaje
         // Por ahora, mostramos error directo si no están cargados
         showInfoModal("No se han cargado los cuestionarios aún. Intenta recargar la página o volver al dashboard.", "Error de Carga");
         return; // Salir si no hay quizzes
     }
     const quiz = window.quizzes.find(q => q && q.id === quizId); // Añadir q && por seguridad
     if (quiz) {
         openQuizBuilder(quiz);
     } else {
         showInfoModal("Error: No se encontró el cuestionario.", "Error al Cargar");
     }
}

function addQuestionBlock(questionData = null) {
    questionTemplate = questionTemplate || document.getElementById('question-template');
    questionsContainer = questionsContainer || document.getElementById('questions-container');
    if (!questionTemplate || !questionsContainer) return;

    const qTempId = `qtmp_${nextQuestionTempId++}`;
    const questionNode = questionTemplate.content.cloneNode(true);
    const questionBlock = questionNode.querySelector('.question-block');
    if (!questionBlock) return;
    questionBlock.dataset.tempId = qTempId; // Guardar ID temporal

    const optionsCont = questionBlock.querySelector('.options-container');
    const questionTextInput = questionBlock.querySelector('.question-text');
    const questionTimeInput = questionBlock.querySelector('.question-time');
    const radioGroupName = `correct_option_${qTempId}`; // Nombre único para grupo de radios

     if (!optionsCont || !questionTextInput || !questionTimeInput) return; // Guard clause

     // Configurar datos si existen
     if (questionData) {
         questionTextInput.value = questionData.text || '';
         questionTimeInput.value = questionData.time_limit || 20;
         questionBlock.dataset.id = questionData.id || ''; // Asignar ID existente

         if (questionData.options && Array.isArray(questionData.options) && questionData.options.length >= 2) {
            questionData.options.forEach(opt => addOptionBlock(optionsCont, radioGroupName, opt));
         } else {
              // Si no hay opciones válidas (o no es array), añadir 2 por defecto
              addOptionBlock(optionsCont, radioGroupName);
              addOptionBlock(optionsCont, radioGroupName);
         }
     } else {
        // Añadir 2 opciones por defecto para preguntas nuevas
        addOptionBlock(optionsCont, radioGroupName);
        addOptionBlock(optionsCont, radioGroupName);
     }
     questionsContainer.appendChild(questionNode);
     updateBuilderUIState(questionBlock); // Actualizar estado específico de este bloque
 }

 function addOptionBlock(optionsContainer, radioGroupName, optionData = null) {
     optionTemplate = optionTemplate || document.getElementById('option-template');
     if (!optionTemplate) return;

     const oTempId = `otmp_${nextQuestionTempId++}`;
     const optionNode = optionTemplate.content.cloneNode(true);
     const optionBlock = optionNode.querySelector('.option-block');
     if (!optionBlock) return;
     optionBlock.dataset.tempId = oTempId;

     const radioInput = optionBlock.querySelector('.option-correct');
     const textInput = optionBlock.querySelector('.option-text');
     if (!radioInput || !textInput) return; // Guard clause

     radioInput.name = radioGroupName; // Asignar nombre de grupo

     if (optionData) {
         textInput.value = optionData.text || '';
         radioInput.checked = optionData.is_correct === true;
         optionBlock.dataset.id = optionData.id || ''; // Asignar ID existente
     }
     optionsContainer.appendChild(optionNode);
 }

 function updateBuilderUIState(questionBlock = null) {
     questionsContainer = questionsContainer || document.getElementById('questions-container');
     if (!questionsContainer) return;

     const allQuestionBlocks = questionsContainer.querySelectorAll('.question-block');
     const canDeleteQuestion = allQuestionBlocks.length > 1;

     // Si se pasa un bloque específico, solo actualiza ese
     const blocksToUpdate = questionBlock ? [questionBlock] : allQuestionBlocks;

     blocksToUpdate.forEach(qb => {
         const deleteQBtn = qb.querySelector('.delete-question-btn');
         // Habilitar/deshabilitar botón de eliminar pregunta GLOBALMENTE
         if (deleteQBtn) deleteQBtn.disabled = !canDeleteQuestion;

         // Lógica para botones de opciones DENTRO del bloque
         const optionsContainer = qb.querySelector('.options-container');
         const addOptionBtn = qb.querySelector('.add-option-btn');
         const deleteOptionBtns = qb.querySelectorAll('.delete-option-btn');

         if (!optionsContainer || !addOptionBtn) return;

         const currentOptionsCount = optionsContainer.querySelectorAll('.option-block').length;
         const canAddOption = currentOptionsCount < 4;
         const canDeleteOption = currentOptionsCount > 2;

         addOptionBtn.disabled = !canAddOption;
         deleteOptionBtns.forEach(delBtn => {
             delBtn.disabled = !canDeleteOption;
         });
     });

     // Si no se pasó un bloque específico, re-evaluar el estado de todos los botones de eliminar pregunta
     if (!questionBlock) {
        allQuestionBlocks.forEach(qb => {
            const deleteQBtn = qb.querySelector('.delete-question-btn');
            if (deleteQBtn) deleteQBtn.disabled = !canDeleteQuestion;
        });
     }
 }

 function saveQuiz(e) {
     e.preventDefault();
     quizTitleInput = quizTitleInput || document.getElementById('quiz-title');
     questionsContainer = questionsContainer || document.getElementById('questions-container');
     quizIdInput = quizIdInput || document.getElementById('quiz-id');
     // Referencias a AMBOS botones de guardar (aunque solo necesitamos uno para deshabilitar)
     const saveBtnBottom = document.getElementById('save-quiz-btn');
     const saveBtnTop = document.getElementById('save-quiz-btn-top-duplicate');

     if (!quizTitleInput || !questionsContainer || !quizIdInput || !saveBtnBottom || !saveBtnTop) {
         console.error("Elementos necesarios para guardar no encontrados.");
         return;
     }

     console.log("Validating and preparing quiz data...");
     const quizData = {
        title: quizTitleInput.value.trim(),
        questions: []
     };

     let isValid = true;
     let firstErrorField = null;
     let errorMessage = '';

     if (!quizData.title) {
         errorMessage = "El título del cuestionario no puede estar vacío.";
         isValid = false; firstErrorField = quizTitleInput;
     }

     const questionBlocks = questionsContainer.querySelectorAll('.question-block');

     if (isValid && questionBlocks.length === 0) {
          errorMessage = "El cuestionario debe tener al menos una pregunta.";
          isValid = false;
     }

     if (isValid) {
         questionBlocks.forEach((qb, qIndex) => {
             if (!isValid) return; // Salir del bucle forEach si ya falló

             const questionTextInput = qb.querySelector('.question-text');
             const questionTimeInput = qb.querySelector('.question-time');
             if (!questionTextInput || !questionTimeInput) { isValid = false; errorMessage = "Error interno al procesar la pregunta."; return; }

             const questionText = questionTextInput.value.trim();
             const questionTime = parseInt(questionTimeInput.value, 10);
             const optionsData = [];
             let correctOptionFound = false;
             const questionId = qb.dataset.id || `q_${Date.now()}_${qIndex}`;

             if (!questionText) {
                 errorMessage = `El texto de la pregunta ${qIndex + 1} no puede estar vacío.`;
                 isValid = false; firstErrorField = questionTextInput; return;
             }
             if (isNaN(questionTime) || questionTime < 5 || questionTime > 120) {
                 errorMessage = `El tiempo límite de la pregunta ${qIndex + 1} debe ser entre 5 y 120 segundos.`;
                 isValid = false; firstErrorField = questionTimeInput; return;
             }

             const optionBlocks = qb.querySelectorAll('.option-block');
             if (optionBlocks.length < 2 || optionBlocks.length > 4) {
                  errorMessage = `La pregunta ${qIndex + 1} debe tener entre 2 y 4 opciones.`;
                  isValid = false; firstErrorField = qb.querySelector('.add-option-btn'); return; // Enfocar el botón de añadir por cercanía
             }

             optionBlocks.forEach((ob, oIndex) => {
                 if (!isValid) return;
                 const optionTextInput = ob.querySelector('.option-text');
                 const optionCorrectInput = ob.querySelector('.option-correct');
                 if (!optionTextInput || !optionCorrectInput) { isValid = false; errorMessage = "Error interno al procesar una opción."; return; }

                 const optionText = optionTextInput.value.trim();
                 const isCorrect = optionCorrectInput.checked;
                 const optionId = ob.dataset.id || `opt_${questionId}_${oIndex}`;

                 if (!optionText) {
                     errorMessage = `El texto de la opción ${oIndex + 1} en la pregunta ${qIndex + 1} no puede estar vacío.`;
                     isValid = false; firstErrorField = optionTextInput; return;
                 }
                 if (isCorrect && correctOptionFound) {
                     errorMessage = `La pregunta ${qIndex + 1} tiene más de una opción marcada como correcta.`;
                     isValid = false; firstErrorField = optionCorrectInput; return;
                 }
                 if (isCorrect) correctOptionFound = true;

                 optionsData.push({ id: optionId, text: optionText, is_correct: isCorrect });
             });
             if (!isValid) return;

             if (!correctOptionFound) {
                 errorMessage = `Debes marcar una opción como correcta en la pregunta ${qIndex + 1}.`;
                 isValid = false; firstErrorField = qb.querySelector('.option-correct'); return; // Find first radio
             }

             quizData.questions.push({
                 id: questionId,
                 text: questionText,
                 time_limit: questionTime,
                 options: optionsData
             });
         });
     } // Fin del if(isValid) inicial

     if (!isValid) {
         console.error("Validation failed:", errorMessage);
         showInfoModal(errorMessage, "Error de Validación"); // Mostrar modal en lugar de alert
         if (firstErrorField) {
            // Podríamos intentar enfocarlo, pero es menos crítico que mostrar el error
            // firstErrorField.focus();
         }
         return; // Detener el guardado
     }

     // --- GUARDADO SIMULADO EN LOCALSTORAGE ---
     console.log("Quiz data is valid. Saving (simulated)...");
     // Deshabilitar AMBOS botones de guardar
     saveBtnBottom.disabled = true;
     saveBtnTop.disabled = true;
     saveBtnBottom.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Guardando...';
     saveBtnTop.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Guardando...';


     const existingQuizId = quizIdInput.value;
     quizData.id = existingQuizId || `quiz_${Date.now()}`;

     // Simular retraso de red/guardado
     setTimeout(() => {
         let saved = false;
         if (!window.quizzes) window.quizzes = []; // Initialize if not existing

         if (existingQuizId) { // Editando
            const index = window.quizzes.findIndex(q => q && q.id === existingQuizId);
            if (index !== -1) {
                window.quizzes[index] = quizData;
                console.log("Quiz updated:", quizData.id);
                saved = true;
            } else {
                console.error("Error: Quiz to edit not found in array");
                showInfoModal("Error al guardar: No se encontró el cuestionario que intentabas editar.", "Error de Guardado");
            }
         } else { // Creando nuevo
            window.quizzes.push(quizData);
            console.log("Quiz created:", quizData.id);
            saved = true;
         }

         // Rehabilitar AMBOS botones de guardar
         saveBtnBottom.disabled = false;
         saveBtnTop.disabled = false;
         saveBtnBottom.innerHTML = 'Guardar Cuestionario';
         saveBtnTop.innerHTML = 'Guardar Cuestionario';

         if (saved) {
             // Funciones de dashboard.js (deben estar accesibles globalmente o importadas)
             if (typeof saveQuizzesToStorage === 'function') saveQuizzesToStorage(); else console.error("saveQuizzesToStorage is not defined");
             if (typeof renderQuizList === 'function') renderQuizList(); else console.error("renderQuizList is not defined");

             // showInfoModal("Cuestionario guardado correctamente."); // Opcional: Notificación de éxito
             if (typeof showView === 'function') showView('dashboard-view'); else console.error("showView is not defined"); // Función de utils.js
         }
     }, 300); // Fin del setTimeout
 }


 // --- Lógica para Importar GIFT ---
 function handleFileSelect(event) {
    giftImportStatus = giftImportStatus || document.getElementById('gift-import-status');
    giftFileNameSpan = giftFileNameSpan || document.getElementById('gift-file-name');
    giftFileInput = giftFileInput || document.getElementById('gift-file-input'); // Needed for reset
    quizTitleInput = quizTitleInput || document.getElementById('quiz-title'); // To potentially set title
    questionsContainer = questionsContainer || document.getElementById('questions-container'); // Needed for check
    quizIdInput = quizIdInput || document.getElementById('quiz-id'); // Needed to check if creating new


    if (!giftImportStatus || !giftFileNameSpan || !giftFileInput || !quizTitleInput || !questionsContainer || !quizIdInput) return;

    giftImportStatus.textContent = ''; // Limpiar estado anterior
    const file = event.target.files[0];
    if (!file) {
        giftFileNameSpan.textContent = ''; giftFileNameSpan.style.display = 'none'; return;
    }
    giftFileNameSpan.textContent = file.name; giftFileNameSpan.style.display = 'inline-block';
    console.log("Selected GIFT file:", file.name);

    if (!file.name.toLowerCase().endsWith('.txt') && !file.name.toLowerCase().endsWith('.gift')) {
        displayError('gift-import-status', 'Error: El archivo debe ser .txt o .gift.'); // Usamos displayError para mensajes en línea
        resetGiftInput(); return;
    }
    const reader = new FileReader();
    reader.onload = (e) => {
         const fileContent = e.target.result;
         try {
             const parsedQuestions = parseGIFT(fileContent);
             if (parsedQuestions.length > 0) {
                 console.log(`Parsed ${parsedQuestions.length} GIFT questions.`);

                 // --- LÓGICA PARA LIMPIAR BLOQUE INICIAL VACÍO ---
                 const isCreatingNewQuiz = !quizIdInput.value;
                 const existingQuestionBlocks = questionsContainer.querySelectorAll('.question-block');
                 let shouldClearInitialBlock = false;
                 if (isCreatingNewQuiz && existingQuestionBlocks.length === 1) {
                     const firstQuestionText = existingQuestionBlocks[0].querySelector('.question-text');
                     const firstOptionsContainer = existingQuestionBlocks[0].querySelector('.options-container');
                     const firstOptions = firstOptionsContainer ? firstOptionsContainer.querySelectorAll('.option-text') : [];
                     let firstOptionsAreEmpty = true;
                     firstOptions.forEach(optInput => { if (optInput.value.trim() !== '') firstOptionsAreEmpty = false; });
                     if (firstQuestionText && firstQuestionText.value.trim() === '' && firstOptionsAreEmpty) {
                         shouldClearInitialBlock = true;
                     }
                 }
                 if (shouldClearInitialBlock) {
                     console.log("Clearing initial empty block before GIFT import.");
                     questionsContainer.innerHTML = '';
                 }
                 // --- FIN LÓGICA LIMPIEZA ---

                 parsedQuestions.forEach(q => addQuestionBlock(q));

                 displayError('gift-import-status', `${parsedQuestions.length} pregunta(s) importada(s) correctamente. Revisa y guarda.`, true); // Mensaje de éxito en línea

                 if (!quizTitleInput.value.trim() && parsedQuestions[0]._giftTitle) {
                     quizTitleInput.value = parsedQuestions[0]._giftTitle;
                 }
                  enableDragAndDrop();
                  updateBuilderUIState(); // Actualizar estado después de añadir
             } else {
                 displayError('gift-import-status', 'No se encontraron preguntas de opción múltiple válidas (formato GIFT) en el archivo.'); // Mensaje de fallo en línea
             }
         } catch (parseError) {
             console.error("Error parsing GIFT:", parseError);
             displayError('gift-import-status', `Error al procesar el archivo: ${parseError.message}`); // Error de parseo en línea
         } finally {
             resetGiftInput(); // Limpiar input de archivo en cualquier caso
         }
     };
    reader.onerror = (e) => {
         console.error("Error reading file:", e);
         displayError('gift-import-status', 'Error al leer el archivo.'); // Error de lectura en línea
         resetGiftInput();
     };
    reader.readAsText(file);
}

function resetGiftInput(){
     giftFileInput = giftFileInput || document.getElementById('gift-file-input');
     if (giftFileInput) giftFileInput.value = null;
     giftFileNameSpan = giftFileNameSpan || document.getElementById('gift-file-name');
     if (giftFileNameSpan) {
         giftFileNameSpan.textContent = '';
         giftFileNameSpan.style.display = 'none';
     }
}

function parseGIFT(text) {
     // Asegurarse de que el texto no sea null o undefined
     if (!text) return [];

     const questions = [];
     // Normalizar saltos de línea y dividir por bloques (dos o más saltos de línea)
     const blocks = text.replace(/\r\n/g, '\n').split(/\n{2,}/);
     let currentTitle = null;

     blocks.forEach((block, index) => {
         block = block.trim();
         // Ignorar comentarios y bloques vacíos
         if (!block || block.startsWith('//')) return;

         let questionText = block;
         let answerBlockContent = '';
         let questionTitle = null;

         // Extraer título si existe ::Título::Pregunta...
         if (questionText.startsWith('::')) {
            const titleEndIndex = questionText.indexOf('::', 2);
            if (titleEndIndex !== -1) {
                questionTitle = questionText.substring(2, titleEndIndex).trim();
                questionText = questionText.substring(titleEndIndex + 2).trim();
                currentTitle = questionTitle; // Recordar título para preguntas sin título propio
            }
         }

         // Encontrar bloque de respuestas {}
         const answerStartIndex = questionText.indexOf('{');
         if (answerStartIndex === -1 || !questionText.endsWith('}')) {
             console.warn(`GIFT block ${index+1} skipped: No answer block {} found.`);
             return; // Saltar este bloque si no tiene formato de respuesta
         }

         answerBlockContent = questionText.substring(answerStartIndex + 1, questionText.length - 1).trim();
         questionText = questionText.substring(0, answerStartIndex).trim();

         // Limpieza básica de HTML y escapes GIFT para el texto de la pregunta
         questionText = questionText.replace(/\[(html|moodle|markdown)\]/gi, ''); // Remover tags de formato [html], [moodle]...
         questionText = questionText.replace(/<[^>]+>/g, ''); // Remover tags HTML <...>
         questionText = questionText.replace(/\\([:={}\[\]#~])/g, '$1'); // Manejar escapes comunes \:, \=, \{, \}, etc.

         const options = [];
         let correctCount = 0;
         // Regex para capturar opciones: [=~] (%peso%)? Texto (#Feedback)?
         const optionRegex = /([=~])(?:%-?\d+(?:\.\d+)?%)?\s*((?:[^\\#=~]|\\.)+?)\s*(?:#((?:[^\\=~]|\\.)*))?\s*(?=[=~]|$)/g;
         let match;

         while ((match = optionRegex.exec(answerBlockContent)) !== null) {
            const type = match[1]; // '=' o '~'
            // Limpiar texto de opción similar a la pregunta
            let optText = match[2].trim(); // Texto capturado
            optText = optText.replace(/<[^>]+>/g, '');
            optText = optText.replace(/\\([:={}\[\]#~])/g, '$1');

            const isCorrect = (type === '=');
            if (isCorrect) correctCount++;

            // Ignorar opciones vacías después de la limpieza
            if (optText) {
                options.push({
                    id: `opt_gift_${index}_${options.length}`,
                    text: optText,
                    is_correct: isCorrect
                    // Podríamos extraer el feedback (match[3]) si fuera necesario
                });
            } else {
                 console.warn(`GIFT block ${index+1}: Skipped empty option text after cleaning.`);
            }
         }

         // Validar que sea opción múltiple con UNA SOLA respuesta correcta y texto de pregunta no vacío
         const isValidMC = options.length >= 2 && options.length <= 4 && correctCount === 1 && questionText.trim();

         if (isValidMC) {
            questions.push({
                id: `q_gift_${index}`,
                text: questionText.trim(),
                time_limit: 20, // Tiempo por defecto
                options: options,
                _giftTitle: questionTitle || currentTitle // Guardar título si existe
            });
         } else {
             console.warn(`GIFT block ${index+1} skipped: Not a valid single-choice MC (options: ${options.length}, correct: ${correctCount}, text: ${!!questionText.trim()}).`);
         }
     });

     return questions;
 }


 // --- Lógica Drag & Drop para Preguntas ---
 function enableDragAndDrop() {
     questionsContainer = questionsContainer || document.getElementById('questions-container');
     if (!questionsContainer) return;
     // Limpiar listeners existentes
     questionsContainer.removeEventListener('dragstart', handleDragStart);
     questionsContainer.removeEventListener('dragover', handleDragOver);
     questionsContainer.removeEventListener('dragleave', handleDragLeave);
     questionsContainer.removeEventListener('drop', handleDrop);
     questionsContainer.removeEventListener('dragend', handleDragEnd);
     // Añadir listeners
     questionsContainer.addEventListener('dragstart', handleDragStart);
     questionsContainer.addEventListener('dragover', handleDragOver);
     questionsContainer.addEventListener('dragleave', handleDragLeave);
     questionsContainer.addEventListener('drop', handleDrop);
     questionsContainer.addEventListener('dragend', handleDragEnd);
 }

 function handleDragStart(e) {
     if (e.target.classList.contains('drag-handle')) {
         draggedQuestion = e.target.closest('.question-block');
         if (draggedQuestion) {
            e.dataTransfer.effectAllowed = 'move';
            setTimeout(() => { if(draggedQuestion) draggedQuestion.classList.add('dragging'); }, 0);
         } else { e.preventDefault(); }
     } else {
         // No prevenir por defecto para permitir selección de texto en inputs
     }
 }

 function handleDragOver(e) {
     e.preventDefault();
     e.dataTransfer.dropEffect = 'move';
     const target = e.target;
     const currentBlock = target.closest('.question-block');
     questionsContainer = questionsContainer || document.getElementById('questions-container');

     if (!dropZone) { dropZone = document.createElement('div'); dropZone.className = 'drop-zone'; }

     if (currentBlock && currentBlock !== draggedQuestion) {
         const rect = currentBlock.getBoundingClientRect();
         const offsetY = e.clientY - rect.top;
         if (offsetY < rect.height / 2) {
             questionsContainer.insertBefore(dropZone, currentBlock);
         } else {
             questionsContainer.insertBefore(dropZone, currentBlock.nextSibling);
         }
     } else if (!currentBlock && target === questionsContainer) {
         if(questionsContainer.lastElementChild !== dropZone) { questionsContainer.appendChild(dropZone); }
     }
 }

 function handleDragLeave(e) {
     // Podríamos quitar la dropzone aquí si salimos del contenedor,
     // pero dejarlo para drop/dragend es más simple y evita parpadeos.
 }

 function handleDrop(e) {
     e.preventDefault();
     questionsContainer = questionsContainer || document.getElementById('questions-container');
     if (draggedQuestion && dropZone && dropZone.parentNode === questionsContainer) {
         questionsContainer.insertBefore(draggedQuestion, dropZone);
     }
     removeDropZone();
 }

 function handleDragEnd(e) {
     if (draggedQuestion) {
         draggedQuestion.classList.remove('dragging');
         draggedQuestion = null;
     }
     removeDropZone();
 }

 function removeDropZone() {
     if (dropZone && dropZone.parentNode) {
         dropZone.parentNode.removeChild(dropZone);
     }
     dropZone = null;
 }

 function initBuilder() {
    // Get elements
    quizBuilderView = document.getElementById('quiz-builder-view');
    addQuestionBtn = document.getElementById('add-question-btn');
    quizBuilderForm = document.getElementById('quiz-builder-form');
    importGiftBtn = document.getElementById('import-gift-btn');
    giftFileInput = document.getElementById('gift-file-input');
    questionsContainer = document.getElementById('questions-container');

    // --- Referencias a TODOS los botones de Cancelar y Guardar ---
    const cancelBtnSmallTop = document.getElementById('cancel-quiz-builder-btn-top'); // El pequeño original
    const cancelBtnDuplicateTop = document.getElementById('cancel-quiz-builder-btn-top-duplicate'); // El duplicado grande
    cancelQuizBuilderBtnBottom = document.getElementById('cancel-quiz-builder-btn-bottom'); // El original inferior (variable global si se usa)
    saveQuizBtn = document.getElementById('save-quiz-btn'); // El original inferior (variable global si se usa)
    const saveBtnDuplicateTop = document.getElementById('save-quiz-btn-top-duplicate'); // El duplicado superior

    // Add Listeners
    if (addQuestionBtn) addQuestionBtn.addEventListener('click', () => { addQuestionBlock(); updateBuilderUIState(); enableDragAndDrop(); });

    // Acción común para todos los botones Cancelar
    const cancelAction = () => {
        if (typeof showView === 'function') {
             showView('dashboard-view');
        } else {
            console.error("showView function is not defined");
            // Fallback si showView no existe
            window.location.hash = ''; // O alguna otra acción para volver
        }
    };
    // Asignar la acción a todos los botones de cancelar encontrados
    if (cancelBtnSmallTop) cancelBtnSmallTop.addEventListener('click', cancelAction);
    if (cancelBtnDuplicateTop) cancelBtnDuplicateTop.addEventListener('click', cancelAction);
    if (cancelQuizBuilderBtnBottom) cancelQuizBuilderBtnBottom.addEventListener('click', cancelAction);

    // Asegurar que los botones de guardar sean de tipo submit y estén asociados al form
    // Esto se hace mejor en el HTML con type="submit" y form="form-id"
    // El listener del FORMULARIO gestionará ambos botones de guardar
    if (quizBuilderForm) {
        quizBuilderForm.addEventListener('submit', saveQuiz);
    } else {
        console.error("Quiz builder form not found!");
    }

    // GIFT import listeners
    if (importGiftBtn) importGiftBtn.addEventListener('click', () => giftFileInput?.click());
    if (giftFileInput) giftFileInput.addEventListener('change', handleFileSelect);

    // Delegación de eventos para botones +/-/delete DENTRO de las preguntas
    if (quizBuilderView) {
        quizBuilderView.addEventListener('click', (e) => {
             const addOptionButton = e.target.closest('.add-option-btn');
             const deleteOptionButton = e.target.closest('.delete-option-btn');
             const deleteQuestionButton = e.target.closest('.delete-question-btn');
             const questionBlock = e.target.closest('.question-block');

             if (addOptionButton && questionBlock) {
                 const optionsCont = questionBlock.querySelector('.options-container');
                 const radioGroupName = `correct_option_${questionBlock.dataset.tempId}`;
                 if (optionsCont) {
                    addOptionBlock(optionsCont, radioGroupName);
                    updateBuilderUIState(questionBlock);
                 }
             } else if (deleteOptionButton && questionBlock) {
                  const optionBlock = deleteOptionButton.closest('.option-block');
                  if (optionBlock) {
                    optionBlock.remove();
                    updateBuilderUIState(questionBlock);
                  }
             } else if (deleteQuestionButton && questionBlock) {
                  const allBlocks = questionsContainer.querySelectorAll('.question-block');
                  if (allBlocks.length > 1) {
                      questionBlock.remove();
                      updateBuilderUIState(); // Actualizar estado global (afecta a los botones de eliminar)
                  } else {
                      showInfoModal("No puedes eliminar la última pregunta. Añade otra primero si deseas reemplazarla.", "Acción No Permitida");
                  }
             }
         });
    }
    // Initial Drag and Drop setup
    enableDragAndDrop();

    // Verificar existencia del modal de info (la instancia se crea bajo demanda)
    if (!document.getElementById('infoModal')) {
        console.warn("Info modal element (#infoModal) not found during initBuilder. Modals will fallback to alerts.");
    } else {
         console.log("Info modal element found.");
    }
 }

 // Asegúrate de que initBuilder se llama en el momento adecuado
 // document.addEventListener('DOMContentLoaded', initBuilder); // Si no depende de la autenticación

// -- dashboard.js ---

// --- dashboard.js ---

// Referencias a elementos (se obtendrán/verificarán dentro de las funciones)
let quizListContainer, createQuizBtn, noQuizzesMessage;
let confirmDeleteModalInstance = null; // Para guardar la instancia del modal

/**
 * Carga los cuestionarios desde localStorage o crea datos de ejemplo.
 */
function loadQuizzesFromStorage() {
    quizListContainer = quizListContainer || document.getElementById('quiz-list');
    noQuizzesMessage = noQuizzesMessage || document.getElementById('no-quizzes-message');
    if (!quizListContainer || !noQuizzesMessage) {
        console.error("Dashboard elements (quiz-list or no-quizzes-message) not found!");
        return;
    }

    console.log("Loading quizzes from localStorage...");
    quizListContainer.innerHTML = '<p class="list-group-item text-muted">Cargando...</p>';
    noQuizzesMessage.style.display = 'none';
    const storedQuizzes = localStorage.getItem('hostQuizzes');
    if (storedQuizzes) {
        try {
            window.quizzes = JSON.parse(storedQuizzes); // Almacenar en scope global (revisar si es la mejor práctica a largo plazo)
        } catch (e) {
            console.error("Error parsing quizzes from localStorage", e);
            window.quizzes = []; // Resetear si hay error
            localStorage.removeItem('hostQuizzes'); // Limpiar dato corrupto
        }
    } else {
        // Si no hay nada, crear datos de ejemplo y guardarlos
        console.log("No quizzes found in localStorage, creating demo data...");
         window.quizzes = [
            { id: 'demo_q1', title: 'Cultura General (Demo)', questions: [{id: 'dq1_1', text: '¿Capital de Francia?', time_limit: 15, options: [{id:'dq1_1_o1', text:'Berlín', is_correct: false},{id:'dq1_1_o2', text:'Madrid', is_correct: false},{id:'dq1_1_o3', text:'París', is_correct: true},{id:'dq1_1_o4', text:'Roma', is_correct: false}]}, {id: 'dq1_2', text: '¿2 + 2?', time_limit: 10, options: [{id:'dq1_2_o1', text:'3', is_correct: false},{id:'dq1_2_o2', text:'4', is_correct: true},{id:'dq1_2_o3', text:'5', is_correct: false}]}]},
            { id: 'demo_q2', title: 'Planetas (Demo)', questions: [{id: 'dq2_1', text: '¿Planeta Rojo?', time_limit: 12, options: [{id:'dq2_1_o1', text:'Júpiter', is_correct: false},{id:'dq2_1_o2', text:'Marte', is_correct: true},{id:'dq2_1_o3', text:'Venus', is_correct: false},{id:'dq2_1_o4', text:'Saturno', is_correct: false}]}] },
        ];
        saveQuizzesToStorage(); // Guardar los de ejemplo
    }
    // Asegurarse de que quizzes sea un array
    if (!Array.isArray(window.quizzes)) {
        console.warn("Loaded quizzes is not an array, resetting.");
        window.quizzes = [];
        localStorage.removeItem('hostQuizzes');
    }
    renderQuizList();
}

/**
 * Guarda el array global window.quizzes en localStorage.
 */
function saveQuizzesToStorage() {
    if (!Array.isArray(window.quizzes)) {
        console.error("Cannot save quizzes, window.quizzes is not an array.");
        return;
    }
    try {
        localStorage.setItem('hostQuizzes', JSON.stringify(window.quizzes));
        console.log("Quizzes saved to localStorage");
    } catch (e) {
        console.error("Error saving quizzes to localStorage", e);
        // Considera mostrar un error menos intrusivo que alert si es posible
        // displayErrorOnPage("Error al guardar los cuestionarios localmente.");
    }
}

/**
 * Configura y muestra el modal de confirmación para eliminar un quiz.
 * @param {string} quizId - El ID del cuestionario a eliminar.
 * @param {string} quizTitle - El título del cuestionario a eliminar.
 */
function setupDeleteConfirmation(quizId, quizTitle) {
    // 1. Obtener referencias a los elementos del modal
    const modalElement = document.getElementById('confirmDeleteQuizModal');
    if (!modalElement) {
        console.error("Modal element #confirmDeleteQuizModal not found!");
        return;
    }
    const quizNameElement = document.getElementById('quizNameToDelete');
    const confirmBtn = document.getElementById('confirmDeleteQuizBtn');

    if (!quizNameElement || !confirmBtn) {
        console.error("Modal content elements (quizNameToDelete or confirmDeleteQuizBtn) not found!");
        return;
    }

    // 2. Rellenar el nombre del quiz en el modal
    quizNameElement.textContent = quizTitle || 'este cuestionario'; // Fallback por si el título es undefined

    // 3. Guardar el ID del quiz a eliminar en el botón de confirmación
    confirmBtn.dataset.quizIdToDelete = quizId;

    // 4. Obtener o crear la instancia del modal y mostrarlo
    if (!confirmDeleteModalInstance) {
        confirmDeleteModalInstance = new bootstrap.Modal(modalElement);
    }
    confirmDeleteModalInstance.show();
}

/**
 * Ejecuta la eliminación real del cuestionario después de la confirmación.
 * @param {string} quizId - El ID del cuestionario a eliminar.
 */
function performQuizDeletion(quizId) {
    console.log("Performing deletion for quiz:", quizId);

    if (!Array.isArray(window.quizzes)) {
        console.error("Cannot delete quiz, window.quizzes is not an array.");
        return;
    }

    // Filtrar el cuestionario del array global
    window.quizzes = window.quizzes.filter(q => q && q.id !== quizId); // Añadir verificación de 'q' por seguridad

    // Guardar el array actualizado en localStorage
    saveQuizzesToStorage();

    // Volver a renderizar la lista para reflejar el cambio en la UI
    renderQuizList();

    console.log(`Quiz ${quizId} deleted successfully.`);
    // No se muestra ningún alert aquí.
}

/**
 * Renderiza la lista de cuestionarios en el contenedor HTML.
 */
function renderQuizList() {
    quizListContainer = quizListContainer || document.getElementById('quiz-list');
    noQuizzesMessage = noQuizzesMessage || document.getElementById('no-quizzes-message');
    if (!quizListContainer || !noQuizzesMessage) return;

    quizListContainer.innerHTML = '';

    // Asegurarse de que window.quizzes exista y sea un array
    if (!window.quizzes || !Array.isArray(window.quizzes) || window.quizzes.length === 0) {
        noQuizzesMessage.style.display = 'block';
    } else {
        noQuizzesMessage.style.display = 'none';
        window.quizzes.forEach(quiz => {
            // Saltar si el quiz es inválido (p.ej., null después de un parseo erróneo)
            if (!quiz || !quiz.id || !quiz.title) {
                console.warn("Skipping invalid quiz object during render:", quiz);
                return;
            }

            const div = document.createElement('div');
            div.className = 'list-group-item d-flex flex-wrap justify-content-between align-items-center gap-2 bg-dark text-light border-secondary';
            const questionCount = quiz.questions && Array.isArray(quiz.questions) ? quiz.questions.length : 0;
            // Usar textContent para evitar problemas de XSS con títulos
            const titleSpan = document.createElement('span');
            titleSpan.className = 'fw-bold flex-grow-1 me-3';
            titleSpan.textContent = `${quiz.title} (${questionCount} ${questionCount === 1 ? 'pregunta' : 'preguntas'})`;

            const buttonGroup = document.createElement('div');
            buttonGroup.className = 'btn-group';
            buttonGroup.setAttribute('role', 'group');
            buttonGroup.innerHTML = `
                <button class="btn btn-sm btn-primary start-quiz-btn" data-quiz-id="${quiz.id}" title="Iniciar Partida"><i class="bi bi-play-fill"></i> Iniciar</button>
                <button class="btn btn-sm btn-secondary edit-quiz-btn" data-quiz-id="${quiz.id}" title="Editar Cuestionario"><i class="bi bi-pencil-fill"></i> Editar</button>
                <button class="btn btn-sm btn-danger delete-quiz-btn" data-quiz-id="${quiz.id}" data-quiz-title="${quiz.title}" title="Eliminar Cuestionario"><i class="bi bi-trash-fill"></i> Eliminar</button>
            `; // Añadido data-quiz-title

            div.appendChild(titleSpan);
            div.appendChild(buttonGroup);

            // Añadir listeners a los botones dentro del grupo
            const startBtn = buttonGroup.querySelector('.start-quiz-btn');
            const editBtn = buttonGroup.querySelector('.edit-quiz-btn');
            const deleteBtn = buttonGroup.querySelector('.delete-quiz-btn');

            if (startBtn) startBtn.addEventListener('click', () => initiateGame(quiz.id)); // initiateGame debe estar definido globalmente o importado
            if (editBtn) editBtn.addEventListener('click', () => loadQuizForEditing(quiz.id)); // loadQuizForEditing debe estar definido globalmente o importado

            // El botón de eliminar ahora llama a setupDeleteConfirmation
            if (deleteBtn) {
                deleteBtn.addEventListener('click', (e) => {
                    const targetButton = e.currentTarget;
                    const idToDelete = targetButton.dataset.quizId;
                    const titleToDelete = targetButton.dataset.quizTitle;
                    if (idToDelete && titleToDelete !== undefined) { // Verificar que ambos datos existen
                        setupDeleteConfirmation(idToDelete, titleToDelete);
                    } else {
                        console.error("Missing data-quiz-id or data-quiz-title on delete button.");
                    }
                });
            }
            quizListContainer.appendChild(div);
        });
    }
}

/**
 * Inicializa la vista del dashboard, añadiendo listeners principales.
 */
function initDashboard() {
    console.log("Initializing Dashboard...");
    createQuizBtn = document.getElementById('create-quiz-btn');

    if (createQuizBtn) {
        // openQuizBuilder debe estar definida globalmente o importada
        createQuizBtn.addEventListener('click', () => openQuizBuilder());
    } else {
        console.warn("Create quiz button not found during initDashboard.");
    }

    // Añadir listener para el botón de confirmación del modal de eliminación
    const confirmDeleteBtn = document.getElementById('confirmDeleteQuizBtn');
    if (confirmDeleteBtn) {
        confirmDeleteBtn.addEventListener('click', (e) => {
            const quizId = e.target.dataset.quizIdToDelete; // Recuperar el ID guardado
            if (quizId) {
                performQuizDeletion(quizId); // Ejecutar la eliminación
                // Ocultar el modal manualmente después de la acción
                if (confirmDeleteModalInstance) {
                    confirmDeleteModalInstance.hide();
                }
            } else {
                console.error("Could not find quizId to delete from modal button dataset.");
            }
        });
    } else {
         console.warn("Confirm delete button (#confirmDeleteQuizBtn) not found during initDashboard.");
    }

    // La carga inicial de quizzes se maneja ahora a través del flujo de autenticación en main.js
    // loadQuizzesFromStorage(); // -> No llamar aquí directamente, esperar a que auth confirme.
}

// Nota: Las funciones `initiateGame` (de game.js) y `loadQuizForEditing`, `openQuizBuilder` (de builder.js)
// deben estar accesibles en el scope global o ser importadas si estás usando módulos.
// La función `initDashboard` debe ser llamada DESPUÉS de una autenticación exitosa.

// --- game.js ---

// --- Lógica del Juego (Host) ---

// Referencias a elementos
let hostLobbyView, hostGameView, hostEndView, gameCodeDisplay, quizLoadStatus,
    playerCount, playerListLobby, startGameBtn, cancelLobbyBtn,
    questionNumberDisplay, questionTextDisplay, hostOptionsPreview,
    timerDisplay, timerBar, resultsDisplay, answerSummaryChart,
    leaderboardList, nextQuestionBtn, endGameBtn, finalPodiumListHost,
    backToDashboardBtn,
    confirmEndGameModal = null, // Variable para el objeto Modal de Bootstrap
    confirmEndGameButton = null; // Variable para el botón de confirmar en el modal


// Variables de estado del juego (declaradas globalmente en main.js, usadas aquí)
// let hostWebSocket = null;
// let currentQuizForGame = null;
// let currentGameCode = null;
// let questionTimerInterval = null;
// let currentQuestionIndex = 0;
// let totalQuestionsInGame = 0;
// let currentQuestionData = null;
// let currentPlayers = {};
// let isQuizDataLoaded = false;


async function initiateGame(quizId) {
    console.log("Initiating game creation process for quizId:", quizId);
    // 1. Find the quiz data first
    const selectedQuiz = window.quizzes.find(q => q.id === quizId);
    if (!selectedQuiz) {
        alert("Error: No se encontró el cuestionario seleccionado."); return;
    }
    if (!selectedQuiz.questions || selectedQuiz.questions.length === 0) {
        alert("Error: Este cuestionario no tiene preguntas."); return;
    }
    console.log("Selected quiz:", selectedQuiz.title);

    // 2. Reset the general game state *before* using the selected quiz data
    resetHostState(); // utils.js function

    // 3. Assign the found quiz to the global variable
    window.currentQuizForGame = JSON.parse(JSON.stringify(selectedQuiz)); // Deep copy

    // 4. Update UI and proceed with API call/WebSocket connection
    gameCodeDisplay = gameCodeDisplay || document.getElementById('game-code-display');
    quizLoadStatus = quizLoadStatus || document.getElementById('quiz-load-status');
    startGameBtn = startGameBtn || document.getElementById('start-game-btn');
    cancelLobbyBtn = cancelLobbyBtn || document.getElementById('cancel-lobby-btn');

    showView('host-lobby-view'); // utils.js function
    if(gameCodeDisplay) gameCodeDisplay.textContent = 'CREANDO...';
    if(quizLoadStatus) quizLoadStatus.textContent = `Cargando quiz: ${window.currentQuizForGame.title}...`;
    if(startGameBtn) startGameBtn.disabled = true;
    if(cancelLobbyBtn) cancelLobbyBtn.disabled = true;

    // 5. Call backend API
    try {
        // --- INICIO LLAMADA REAL A LA API ---
        const response = await fetch('/create_game/', { method: 'POST' });

        if (!response.ok) {
             let errorDetail = `Error ${response.status}`;
             try {
                 const errorData = await response.json();
                 errorDetail = errorData.detail || errorDetail;
             } catch (e) {
                console.warn("Could not parse error response JSON from /create_game/");
             }
             throw new Error(errorDetail);
        }
        const data = await response.json();
        // --- FIN LLAMADA REAL A LA API ---

        if (!data || !data.game_code) {
            throw new Error("La respuesta del servidor no incluyó un código de partida.");
        }

        window.currentGameCode = data.game_code;
        console.log("Game shell created successfully by SERVER! Code:", window.currentGameCode);

        // 6. Connect WebSocket con el código real
        connectHostWebSocket(window.currentGameCode);

        cancelLobbyBtn = cancelLobbyBtn || document.getElementById('cancel-lobby-btn');
        if(cancelLobbyBtn) cancelLobbyBtn.disabled = false;

    } catch (error) {
        console.error("Failed to create game shell:", error);
        alert(`Error al crear la partida: ${error.message}`);
        resetHostState();
        showView('dashboard-view');
    }
} // Fin de la función initiateGame


// Función para crear el HTML del indicador de espera
function createWaitingIndicatorHTML() {
    return `<li class="list-group-item text-muted waiting-indicator">Esperando jugadores<span class="dots">...</span></li>`;
}

function connectHostWebSocket(gameCode) {
     // Use actual hostname if deployed, or localhost/port during development
     const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
     // Make sure this points to your backend WebSocket endpoint
     const wsUrl = `${wsProtocol}//${window.location.host}/ws/${gameCode}`; // Adjust if backend runs elsewhere

     console.log(`Host connecting to WebSocket: ${wsUrl}`);
     gameCodeDisplay = gameCodeDisplay || document.getElementById('game-code-display');
     playerListLobby = playerListLobby || document.getElementById('player-list-lobby'); // Asegurarse que se obtiene
     playerCount = playerCount || document.getElementById('player-count');
     startGameBtn = startGameBtn || document.getElementById('start-game-btn');
     quizLoadStatus = quizLoadStatus || document.getElementById('quiz-load-status');

     if(gameCodeDisplay) gameCodeDisplay.textContent = gameCode;
     window.currentPlayers = {}; // Reset players for the new game

     // -------- MODIFICADO --------
     // Establecer el indicador de espera inicial
     if(playerListLobby) playerListLobby.innerHTML = createWaitingIndicatorHTML();
     // --------------------------

     if(playerCount) playerCount.textContent = '0';
     if(startGameBtn) startGameBtn.disabled = true;
     window.isQuizDataLoaded = false;

     // Limpiar conexión anterior si existiera
     if (window.hostWebSocket && window.hostWebSocket.readyState !== WebSocket.CLOSED && window.hostWebSocket.readyState !== WebSocket.CLOSING) {
         console.warn("Closing previous WebSocket connection...");
         window.hostWebSocket.close();
     }

     try {
        window.hostWebSocket = new WebSocket(wsUrl);
     } catch (error) {
        console.error("Failed to create WebSocket:", error);
        alert("Error al intentar conectar con el servidor de juego. Asegúrate de que el servidor esté corriendo.");
        if(quizLoadStatus) quizLoadStatus.textContent = "Error de conexión.";
        resetHostState();
        showView('dashboard-view');
        return;
     }


     window.hostWebSocket.onopen = () => {
         console.log("Host WebSocket connected!");
         // a) Unirse como host
         const hostNickname = window.hostEmail || `Host_${gameCode}`;
         sendHostCommand("join_game", { nickname: hostNickname });

         // b) Enviar los datos del quiz
         if (window.currentQuizForGame) {
             console.log("Sending quiz data to backend...");
             if(quizLoadStatus) quizLoadStatus.textContent = `Enviando datos de '${window.currentQuizForGame.title}'...`;
             sendHostCommand("load_quiz_data", window.currentQuizForGame);
         } else {
             console.error("Critical Error: currentQuizForGame is null when WebSocket opened!");
             if(quizLoadStatus) quizLoadStatus.textContent = "Error: No hay datos de quiz para enviar.";
             alert("Error crítico: No se pudieron cargar los datos del cuestionario para enviar.");
             cancelGame(false); // Cancelar sin preguntar
         }
     };

     window.hostWebSocket.onmessage = (event) => {
         console.debug("Host received message:", event.data);
         try {
             const message = JSON.parse(event.data);
             handleHostWebSocketMessage(message);
         } catch (error) {
             console.error("Host failed to parse message:", error, event.data);
         }
     };

     window.hostWebSocket.onerror = (error) => {
         console.error("Host WebSocket error:", error);
         alert("Error de conexión WebSocket como anfitrión. La partida no puede continuar.");
         // onclose will handle cleanup
         showView('dashboard-view');
     };

     window.hostWebSocket.onclose = (event) => {
         console.log("Host WebSocket closed:", event.code, event.reason, `WasClean: ${event.wasClean}`);
         hostEndView = hostEndView || document.getElementById('host-end-view'); // Ensure element is checked
         const gameEndedNormally = hostEndView && hostEndView.style.display !== 'none';

         if (!gameEndedNormally) {
              if (!event.wasClean && event.code !== 1000 && event.code !== 1008) { // Ignore expected closures
                  alert(`Conexión perdida inesperadamente (Host): ${event.reason || event.code}. Volviendo al dashboard.`);
              }
              resetHostState();
              const authView = document.getElementById('auth-view'); // Check if logged out
              if (authView && authView.style.display === 'none') {
                 showView('dashboard-view');
              }
         } else {
             console.log("WebSocket closed after game finished.");
             window.hostWebSocket = null; // Clear WS variable but keep state for podium view
         }
     };
}

function handleHostWebSocketMessage(message) {
     const type = message.type;
     const payload = message.payload;
     console.log("Host processing message:", type, payload);

     // Ensure UI elements are available
     startGameBtn = startGameBtn || document.getElementById('start-game-btn');
     quizLoadStatus = quizLoadStatus || document.getElementById('quiz-load-status');
     resultsDisplay = resultsDisplay || document.getElementById('results-display');
     nextQuestionBtn = nextQuestionBtn || document.getElementById('next-question-btn');
     timerBar = timerBar || document.getElementById('timer-bar');

     switch (type) {
         case 'join_ack':
             console.log(`Join Ack received for ${payload.nickname}. Msg: ${payload.message}`);
             if (!window.currentPlayers[payload.nickname]) {
                 addPlayerToLobby(payload.nickname);
                 updatePlayerCount(Object.keys(window.currentPlayers).length);
             }
             break;

        case 'quiz_loaded_ack':
            console.log("Backend acknowledged quiz data load:", payload);
            window.isQuizDataLoaded = true;
            if (quizLoadStatus) {
                quizLoadStatus.textContent = `Quiz '${payload.title}' (${payload.question_count} preg.) cargado. ¡Listo para empezar!`;
                quizLoadStatus.className = 'mb-3 text-success';
            }
            if(startGameBtn) startGameBtn.disabled = Object.keys(window.currentPlayers).length === 0;
            break;

         case 'player_joined':
             console.log("Player joined lobby:", payload.nickname);
              addPlayerToLobby(payload.nickname);
             updatePlayerCount(payload.player_count);
             // Habilitar botón Start si quiz cargado y hay jugadores
             // (La actualización de player_count ya maneja esto implícitamente)
             // if (window.isQuizDataLoaded && startGameBtn) {
             //     startGameBtn.disabled = payload.player_count === 0; // player_count del backend incluye host? Usar currentPlayers
             // }
             break;

         case 'player_left':
             console.log("Player left lobby:", payload.nickname);
              removePlayerFromLobby(payload.nickname);
             updatePlayerCount(payload.player_count);
             // Deshabilitar si no quedan jugadores
             // (La actualización de player_count ya maneja esto implícitamente)
             // if(startGameBtn) startGameBtn.disabled = Object.keys(window.currentPlayers).length === 0;
             break;

          case 'game_started':
             console.log("Game started acknowledge by server.");
             showView('host-game-view');
             break;

          case 'new_question':
              console.log("Host received new question data.");
              window.currentQuestionData = payload;
              displayHostQuestion(payload);
              updateLeaderboard([]); // Clear leaderboard for new question
              if(resultsDisplay) resultsDisplay.style.display = 'none';
              if(nextQuestionBtn) nextQuestionBtn.disabled = false; // Habilitar "Siguiente" para mostrar marcador
              break;

          case 'update_scoreboard':
              console.log("Host received scoreboard update.");
              if(window.questionTimerInterval) clearInterval(window.questionTimerInterval);
              if (timerBar) {
                   timerBar.style.width = '0%';
                   timerBar.textContent = 'Resultados';
                   timerBar.classList.remove('progress-bar-animated', 'bg-danger', 'bg-info');
               }
              updateLeaderboard(payload.scoreboard);
              if(resultsDisplay) resultsDisplay.style.display = 'block';
              // El avance será automático o por clic del host (dejamos el botón habilitado)
              if(nextQuestionBtn) nextQuestionBtn.disabled = false;
              break;

           case 'game_over':
               console.log("!!!!!! Host received game_over message from server", payload); // DEBUG
               console.log("Host received game over.");
               if(window.questionTimerInterval) clearInterval(window.questionTimerInterval);
               displayHostFinalPodium(payload);
               console.log("!!!!!! Before showing host-end-view"); // DEBUG
               showView('host-end-view');
               console.log("!!!!!! After showing host-end-view"); // DEBUG
               if (window.hostWebSocket && window.hostWebSocket.readyState === WebSocket.OPEN) {
                    window.hostWebSocket.close(1000, "Game finished normally");
               }
               break;

           case 'error':
                console.error("Host received error from server:", payload.message, payload.code);
                alert(`Error del Servidor (Host): ${payload.message}`);
                 if (payload.code === 'QUIZ_LOAD_ERROR' || payload.message?.includes("Formato de cuestionario inválido")) {
                     if(quizLoadStatus) {
                        quizLoadStatus.textContent = `Error cargando quiz: ${payload.message}`;
                        quizLoadStatus.className = 'mb-3 text-danger';
                     }
                     cancelGame(false);
                 } else if (payload.code === 'HOST_DISCONNECTED') {
                     alert("El servidor detectó una desconexión del host.");
                      cancelGame(false);
                 }
                break;

           // Mensaje informativo opcional si el host pulsa 'Siguiente' durante el marcador
           case 'info':
               console.log("Server info:", payload.message);
               // Podríamos mostrar un toast o nada
               break;

         default:
             console.warn("Host received unhandled message type:", type, payload);
     }
}

function addPlayerToLobby(nickname) {
     playerListLobby = playerListLobby || document.getElementById('player-list-lobby');
     if (!playerListLobby) return;

     const hostNicknamePattern = /^(Host_|admin)/i;
     if (hostNicknamePattern.test(nickname)) {
         console.log("Host join confirmed, not adding to visible list.");
         return; // No mostrar host en la lista visible
     }

     if (window.currentPlayers[nickname]) return; // Evitar duplicados
     window.currentPlayers[nickname] = true; // Marcar como presente

     // -------- MODIFICADO --------
     // Si es el primer jugador REAL, limpiar el indicador de espera
     const waitingIndicator = playerListLobby.querySelector('.waiting-indicator');
     if (waitingIndicator) {
         waitingIndicator.remove();
     }
     // --------------------------

     // Añadir el jugador a la lista
     const li = document.createElement('li');
     li.className = 'list-group-item';
     li.textContent = nickname;
     li.id = `player-lobby-${nickname.replace(/\W/g, '_')}`; // ID más seguro
     playerListLobby.appendChild(li);
 }

 function removePlayerFromLobby(nickname) {
    playerListLobby = playerListLobby || document.getElementById('player-list-lobby');

     const hostNicknamePattern = /^(Host_|admin)/i;
      if (hostNicknamePattern.test(nickname)) {
         console.log("Host left confirmation received.");
         return; // Ignorar si es el host (ya se maneja en disconnect)
     }

     delete window.currentPlayers[nickname]; // Quitar del registro interno
     const li = document.getElementById(`player-lobby-${nickname.replace(/\W/g, '_')}`);
     if (li) {
         li.remove();
     }

     // -------- MODIFICADO --------
     // Si no quedan jugadores REALES y el elemento de la lista existe,
     // volver a mostrar el indicador de espera
     if (playerListLobby && Object.keys(window.currentPlayers).length === 0) {
          playerListLobby.innerHTML = createWaitingIndicatorHTML();
     }
     // --------------------------
 }

 function updatePlayerCount(backendPlayerCount) {
     playerCount = playerCount || document.getElementById('player-count');
     startGameBtn = startGameBtn || document.getElementById('start-game-btn');

     // Contar solo los jugadores reales que tenemos registrados en el frontend
     const displayCount = Object.keys(window.currentPlayers).length;
     if(playerCount) playerCount.textContent = displayCount;
     // Habilitar botón Start solo si el quiz está cargado Y hay al menos 1 jugador (real)
     if(startGameBtn) startGameBtn.disabled = !(window.isQuizDataLoaded && displayCount > 0);
 }

function sendHostCommand(commandType, data = {}) {
     console.log("Attempting to send command:", commandType); // DEBUG
     console.log("WebSocket state:", window.hostWebSocket?.readyState); // DEBUG (1 means OPEN)
     if (!window.hostWebSocket || window.hostWebSocket.readyState !== WebSocket.OPEN) {
         console.error("Host WebSocket is not connected to send command:", commandType);
         if (commandType === 'start_game' || commandType === 'next_question' || commandType === 'end_game') {
             alert("Error: No se pudo enviar el comando. Conexión perdida.");
              resetHostState();
              showView('dashboard-view');
         }
         return false;
     }
     try {
        const message = JSON.stringify({ type: commandType, payload: data });
        console.log("Host sending command:", commandType, data);
        window.hostWebSocket.send(message);
        return true;
     } catch (error) {
         console.error("Error sending command:", commandType, error);
         return false;
     }
 }

function displayHostQuestion(questionPayload) {
    questionNumberDisplay = questionNumberDisplay || document.getElementById('question-number');
    questionTextDisplay = questionTextDisplay || document.getElementById('question-text');
    hostOptionsPreview = hostOptionsPreview || document.getElementById('host-options-preview');
    if (!questionNumberDisplay || !questionTextDisplay || !hostOptionsPreview) return;

    window.currentQuestionIndex = questionPayload.question_number - 1;
    window.totalQuestionsInGame = questionPayload.total_questions;

    questionNumberDisplay.textContent = `Pregunta ${questionPayload.question_number} / ${window.totalQuestionsInGame}`;
    questionTextDisplay.textContent = questionPayload.question_text;

    hostOptionsPreview.innerHTML = '';
    const symbols = ['▲', '◆', '●', '■'];
    const colors = ['text-danger', 'text-primary', 'text-warning', 'text-success'];

    if (window.currentQuizForGame && window.currentQuizForGame.questions[window.currentQuestionIndex]) {
        const originalQuestion = window.currentQuizForGame.questions[window.currentQuestionIndex];
        const correctOptionId = originalQuestion.options.find(opt => opt.is_correct)?.id;

        questionPayload.options.forEach((opt, index) => {
            const div = document.createElement('div');
            div.className = `col-md-6 small`;
            let content = `<strong class="fs-5 ${colors[index % 4]}">${symbols[index % 4]}</strong> ${opt.text}`;
            if (opt.id === correctOptionId) {
                content += ' <i class="bi bi-check-circle-fill text-success ms-1" title="Respuesta Correcta"></i>';
                div.classList.add('fw-bold');
            } else {
                div.classList.add('text-muted');
            }
            div.innerHTML = content;
            hostOptionsPreview.appendChild(div);
        });
    } else {
         console.warn("Could not find original quiz data to mark correct answer for host preview.");
         questionPayload.options.forEach((opt, index) => {
            const div = document.createElement('div');
            div.className = `col-md-6 small ${colors[index % 4]}`;
            div.innerHTML = `<strong class="fs-5">${symbols[index % 4]}</strong> ${opt.text}`;
            hostOptionsPreview.appendChild(div);
         });
    }
    startHostTimer(questionPayload.time_limit);
 }

 function startHostTimer(duration) {
     timerBar = timerBar || document.getElementById('timer-bar');
     if (!timerBar) return;

     if (window.questionTimerInterval) clearInterval(window.questionTimerInterval);
     let timeLeft = duration;
     let maxTime = duration;
     timerBar.style.width = '100%';
     timerBar.className = 'progress-bar progress-bar-striped progress-bar-animated bg-info';
     timerBar.textContent = `${timeLeft}s`;
     timerBar.setAttribute('aria-valuenow', timeLeft);
     timerBar.setAttribute('aria-valuemax', maxTime);

     window.questionTimerInterval = setInterval(() => {
         timeLeft--;
         const percentage = Math.max(0, (timeLeft / maxTime) * 100);
         timerBar = timerBar || document.getElementById('timer-bar');
         if (!timerBar) {
            clearInterval(window.questionTimerInterval);
            return;
         }

         timerBar.style.width = `${percentage}%`;
         timerBar.textContent = `${timeLeft}s`;
         timerBar.setAttribute('aria-valuenow', timeLeft);

         if (timeLeft <= 5 && !timerBar.classList.contains('bg-danger')) {
             timerBar.classList.remove('bg-info');
             timerBar.classList.add('bg-danger');
         }

         if (timeLeft <= 0) {
             clearInterval(window.questionTimerInterval);
             window.questionTimerInterval = null;
             timerBar.textContent = "¡Tiempo!";
             timerBar.classList.remove('progress-bar-animated');
             // Ya no habilitamos 'Next' aquí, el servidor controla el flujo
             // nextQuestionBtn = nextQuestionBtn || document.getElementById('next-question-btn');
             // if(nextQuestionBtn) nextQuestionBtn.disabled = false;
             console.log("Host timer finished.");
             // El servidor debería enviar 'update_scoreboard' ahora o pronto
         }
     }, 1000);
 }

function updateLeaderboard(leaderboardData) {
     leaderboardList = leaderboardList || document.getElementById('leaderboard');
     if (!leaderboardList) return;

     leaderboardList.innerHTML = '';
     if (leaderboardData && leaderboardData.length > 0) {
         leaderboardData.slice(0, 5).forEach(player => {
            const li = document.createElement('li');
            li.className = 'list-group-item d-flex justify-content-between align-items-center';
             li.innerHTML = `<span>${player.rank}. ${player.nickname}</span><span class="badge bg-primary rounded-pill">${player.score}</span>`;
             leaderboardList.appendChild(li);
         });
     } else {
         leaderboardList.innerHTML = '<li class="list-group-item text-muted">Esperando resultados...</li>';
     }
 }

function displayHostFinalPodium(podiumData) {
     finalPodiumListHost = finalPodiumListHost || document.getElementById('final-podium-list-host');
     if (!finalPodiumListHost) return;
     console.log("!!!!!! Entered displayHostFinalPodium", podiumData); // DEBUG
     finalPodiumListHost.innerHTML = '';
      if (podiumData && podiumData.podium && podiumData.podium.length > 0) {
         podiumData.podium.forEach((player) => {
            const li = document.createElement('li');
            li.className = 'list-group-item d-flex justify-content-between align-items-center fs-5';
            let medal = '';
             if (player.rank === 1) medal = '🥇 ';
            else if (player.rank === 2) medal = '🥈 ';
            else if (player.rank === 3) medal = '🥉 ';
             else medal = `${player.rank}. `;
             li.innerHTML = `<span>${medal}${player.nickname}</span><span class="badge bg-warning text-dark rounded-pill p-2">${player.score} pts</span>`;
             finalPodiumListHost.appendChild(li);
        });
     } else {
          finalPodiumListHost.innerHTML = '<li class="list-group-item text-muted">No se pudo cargar el podio.</li>';
     }
 }

function cancelGame(confirmNeeded = true) {
     // Usar confirm nativo aquí está bien para cancelar desde el lobby
     let cancelConfirmed = !confirmNeeded;
     if (confirmNeeded) {
        cancelConfirmed = confirm('¿Seguro que quieres cancelar esta partida? Se desconectarán todos los jugadores.');
     }

     if (cancelConfirmed) {
         console.log("Host cancelling the game.");
         if (window.hostWebSocket && window.hostWebSocket.readyState === WebSocket.OPEN) {
              window.hostWebSocket.close(1000, "Host cancelled game");
         }
         resetHostState();
         showView('dashboard-view');
    }
}

function initGameControls() {
    // Get elements for game controls
    hostLobbyView = document.getElementById('host-lobby-view');
    hostGameView = document.getElementById('host-game-view');
    hostEndView = document.getElementById('host-end-view');
    gameCodeDisplay = document.getElementById('game-code-display');
    startGameBtn = document.getElementById('start-game-btn');
    cancelLobbyBtn = document.getElementById('cancel-lobby-btn');
    nextQuestionBtn = document.getElementById('next-question-btn');
    endGameBtn = document.getElementById('end-game-btn');
    backToDashboardBtn = document.getElementById('back-to-dashboard-btn');
    resultsDisplay = document.getElementById('results-display');

    // Obtener referencias al modal y su botón de confirmación (PARA FINALIZAR JUEGO)
    const confirmModalElement = document.getElementById('confirmEndGameModal');
    confirmEndGameButton = document.getElementById('confirmEndGameBtn');

    // Inicializar el objeto Modal de Bootstrap si el elemento existe
    if (confirmModalElement) {
        if (!confirmEndGameModal) {
             try {
                confirmEndGameModal = new bootstrap.Modal(confirmModalElement);
             } catch (e) {
                 console.error("Error initializing Bootstrap Modal:", e);
                 confirmEndGameModal = null;
             }
        }
    } else {
        // Solo advertir si no se encuentra el modal, no es un error crítico si no existe
        console.warn("End game confirmation modal element (#confirmEndGameModal) not found!");
    }

    // Add listeners

    if (startGameBtn) {
        startGameBtn.addEventListener('click', () => {
            if (!startGameBtn.disabled) {
                startGameBtn.disabled = true;
                startGameBtn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Iniciando...';
                sendHostCommand('start_game');
            }
        });
    }

    if (cancelLobbyBtn) cancelLobbyBtn.addEventListener('click', () => cancelGame(true)); // Usa confirm nativo
    if (gameCodeDisplay) gameCodeDisplay.addEventListener('click', copyGameCode);

    if (nextQuestionBtn) {
         // El botón "Siguiente" ahora solo fuerza mostrar el marcador si estamos en QUESTION_DISPLAY
         // o acelera el avance si estamos en LEADERBOARD (aunque lo ignoremos aquí)
        nextQuestionBtn.addEventListener('click', () => {
            if (!nextQuestionBtn.disabled) {
               // No lo deshabilitamos inmediatamente, el servidor controla el flujo
               // nextQuestionBtn.disabled = true;
               // resultsDisplay = resultsDisplay || document.getElementById('results-display');
               // if(resultsDisplay) resultsDisplay.style.display = 'none'; // No ocultar aquí
               sendHostCommand('next_question');
            }
        });
    }

    // ---- LISTENER PARA #end-game-btn (USA EL MODAL) ----
    if (endGameBtn) {
        endGameBtn.addEventListener('click', () => {
            console.log("!!!!!! End Game button listener triggered - checking modal");
            if (confirmEndGameModal) {
                 console.log("!!!!!! Showing Bootstrap Modal for end game confirmation.");
                 confirmEndGameModal.show();
            } else {
                 console.warn("End game modal not available. Using basic confirm().");
                 if (confirm('¿Estás seguro de que quieres finalizar la partida ahora? (Fallback)')) {
                      console.log("!!!!!! Fallback Confirmation OK, calling sendHostCommand...");
                      const sent = sendHostCommand('end_game');
                      if(sent) { // Deshabilitar botones si se envió el comando
                          if(nextQuestionBtn) nextQuestionBtn.disabled = true;
                          if(endGameBtn) endGameBtn.disabled = true;
                      }
                 } else {
                      console.log("!!!!!! Fallback Confirmation cancelled.");
                 }
            }
        });
    }
    // -----------------------------------------------

    // ---- LISTENER PARA EL BOTÓN DENTRO DEL MODAL ----
    if (confirmEndGameButton) {
        // Podríamos necesitar remover el listener anterior si initGameControls se llama múltiples veces
        // pero asumimos que solo se llama una vez en main.js
        confirmEndGameButton.addEventListener('click', () => {
            console.log("!!!!!! Modal Confirmation OK, calling sendHostCommand...");
            const sent = sendHostCommand('end_game');
            if(sent) {
                // Deshabilitar botones para feedback inmediato
                if(nextQuestionBtn) nextQuestionBtn.disabled = true;
                if(endGameBtn) endGameBtn.disabled = true;
            }
            if (confirmEndGameModal) { // Ocultar modal si existe
                confirmEndGameModal.hide();
            }
        });
    } else {
        // Solo advertir si el botón del modal no se encuentra
        console.warn("Confirmation button inside modal (#confirmEndGameBtn) not found!");
    }
    // ------------------------------------------------------

    if (backToDashboardBtn) {
        backToDashboardBtn.addEventListener('click', () => {
             resetHostState();
             loadQuizzesFromStorage(); // Reload quizzes
             showView('dashboard-view');
        });
    }
} // Fin de initGameControls


// --- main.js ---

// --- Punto de Entrada Principal y Estado Global ---

// Variables Globales (declaradas en el scope global 'window' para acceso simple)
let hostWebSocket = null;
let hostAuthToken = localStorage.getItem('hostAuthToken') || null;
let hostEmail = localStorage.getItem('hostEmail') || null;
let quizzes = []; // Lista de quizzes (cargada desde dashboard.js)
let currentQuizForBuilder = null; // Quiz actual en el editor (manejado en builder.js)
let currentQuizForGame = null; // Quiz seleccionado para jugar (manejado en game.js)
let currentGameCode = null; // Código de la partida actual (manejado en game.js)
let questionTimerInterval = null; // (manejado en game.js)
let currentQuestionIndex = 0; // Índice base 0 (manejado en game.js)
let totalQuestionsInGame = 0; // (manejado en game.js)
let currentQuestionData = null; // Datos de la pregunta actual (manejado en game.js)
let currentPlayers = {}; // { nickname: true } (manejado en game.js)
let isQuizDataLoaded = false; // Flag carga quiz en backend (manejado en game.js)

// --- Inicialización General ---
document.addEventListener('DOMContentLoaded', () => {
    console.log("DOM fully loaded and parsed. Initializing modules...");

    // Inicializar cada módulo para que obtenga sus elementos y configure listeners
    initAuth();       // Set up login/register/logout listeners
    initDashboard();  // Set up dashboard listeners (create quiz)
    initBuilder();    // Set up quiz builder listeners (add/delete question/option, save, import, D&D)
    initGameControls(); // Set up game control listeners (start, cancel, next, end, back to dash)

    // Carga Inicial basada en autenticación
    if (hostAuthToken && hostEmail) {
         console.log("Host token found, loading dashboard...");
         loadQuizzesFromStorage(); // Carga inicial de quizzes desde dashboard.js
         showView('dashboard-view'); // Muestra vista inicial desde utils.js
    } else {
         console.log("Host token not found, showing auth.");
         showView('auth-view'); // Muestra vista inicial desde utils.js
    }
});

// Nota: Este enfoque usa variables globales (asignadas a `window`).
// Para una aplicación más grande, considera usar Módulos ES6 (`import`/`export`)
// o un objeto de estado global para gestionar las dependencias de forma más explícita.


// --- ui-helpers.js ---
// Funciones para cambiar entre vistas (secciones)
function showView(viewId) {
  const views = document.querySelectorAll('main > section');
  views.forEach(view => {
    view.style.display = view.id === viewId ? 'block' : 'none';
  });
}

// Otras funciones útiles: mostrar errores, limpiar formularios, etc.
function displayError(elementId, message) {
  const errorElement = document.getElementById(elementId);
  if (errorElement) {
    errorElement.textContent = message;
    errorElement.style.display = message ? 'block' : 'none';
  }
}
// ... más helpers ...


// --- utils.js

// --- UI Helpers ---
function showView(viewId) {
    const views = document.querySelectorAll('main > section');
    views.forEach(view => {
        view.style.display = view.id === viewId ? 'block' : 'none';
    });
    // Control visibilidad botón logout y email
    const isLoggedIn = viewId !== 'auth-view';
    const logoutBtn = document.getElementById('logout-button');
    const emailDisplay = document.getElementById('host-email-display');

    if (logoutBtn) logoutBtn.style.display = isLoggedIn ? 'inline-block' : 'none';

     if (emailDisplay) {
         if (isLoggedIn && typeof hostEmail !== 'undefined' && hostEmail) { // Check if hostEmail is defined
             emailDisplay.textContent = hostEmail;
             emailDisplay.style.display = 'inline-block';
        } else {
             emailDisplay.style.display = 'none';
        }
    }
     console.log("Host showing view:", viewId);
}

function displayError(elementId, message, isSuccess = false) {
    const errorElement = document.getElementById(elementId);
    if (errorElement) {
        errorElement.textContent = message || '';
        errorElement.className = isSuccess ? 'text-success mt-2' : 'text-danger mt-2';
         console.log(`Host status/error display [${elementId}]: ${message}`);
    } else {
        console.warn(`displayError: Element with ID ${elementId} not found.`);
    }
}

function resetHostState() {
     // No reseteamos el estado de auth aquí, se hace en logout
     window.currentQuizForBuilder = null; // Use window scope for globals in this approach
     window.currentQuizForGame = null;
     window.currentGameCode = null;

     if (window.hostWebSocket && window.hostWebSocket.readyState !== WebSocket.CLOSED && window.hostWebSocket.readyState !== WebSocket.CLOSING) {
         window.hostWebSocket.close(1000, "Host state reset");
     }
     window.hostWebSocket = null;
     if (window.questionTimerInterval) clearInterval(window.questionTimerInterval);
     window.questionTimerInterval = null;
     window.currentQuestionIndex = 0;
     window.totalQuestionsInGame = 0;
     window.currentQuestionData = null;
     window.currentPlayers = {}; // Limpiar jugadores del lobby
     window.isQuizDataLoaded = false; // Resetear flag

     // Limpiar UI específica del juego (asegurarse que los elementos existan)
     const playerListLobby = document.getElementById('player-list-lobby');
     const playerCount = document.getElementById('player-count');
     const leaderboardList = document.getElementById('leaderboard');
     const gameCodeDisplay = document.getElementById('game-code-display');
     const startGameBtn = document.getElementById('start-game-btn');
     const nextQuestionBtn = document.getElementById('next-question-btn');
     const finalPodiumListHost = document.getElementById('final-podium-list-host');
     const quizLoadStatus = document.getElementById('quiz-load-status');
     const resultsDisplay = document.getElementById('results-display');

     if(playerListLobby) playerListLobby.innerHTML = '<li class="list-group-item text-muted">Esperando jugadores...</li>';
     if(playerCount) playerCount.textContent = '0';
     if(leaderboardList) leaderboardList.innerHTML = '<li class="list-group-item text-muted">Esperando respuestas...</li>';
     if(gameCodeDisplay) gameCodeDisplay.textContent = '------';
     if(startGameBtn) {
        startGameBtn.disabled = true;
        startGameBtn.innerHTML = '<i class="bi bi-play-circle-fill"></i> Empezar Juego';
     }
     if(nextQuestionBtn) nextQuestionBtn.disabled = true;
     if(finalPodiumListHost) finalPodiumListHost.innerHTML = '';
     if(quizLoadStatus) quizLoadStatus.textContent = '';
     if(resultsDisplay) resultsDisplay.style.display = 'none';

     console.log("Host game state reset (excluding auth)");
}

 function copyGameCode() {
    const gameCodeDisplay = document.getElementById('game-code-display');
    if (window.currentGameCode && gameCodeDisplay && gameCodeDisplay.textContent !== 'CREANDO...' && gameCodeDisplay.textContent !== '------') {
        navigator.clipboard.writeText(window.currentGameCode).then(() => {
            const originalText = gameCodeDisplay.textContent;
            const originalTitle = gameCodeDisplay.title;
            gameCodeDisplay.textContent = '¡COPIADO!';
            gameCodeDisplay.title = ''; // Quitar tooltip temporalmente
            setTimeout(() => {
                // Check if element still exists before updating
                const currentDisplay = document.getElementById('game-code-display');
                if (currentDisplay) {
                    currentDisplay.textContent = originalText;
                    currentDisplay.title = originalTitle;
                }
             }, 1500);
        }).catch(err => {
            console.error('Error copying game code:', err);
        });
    }
}

